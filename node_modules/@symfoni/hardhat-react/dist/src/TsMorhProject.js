"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TsMorphProject = exports.contractInterfaceName = void 0;
const fs_extra_1 = require("fs-extra");
const path_1 = __importDefault(require("path"));
const ts_morph_1 = require("ts-morph");
const ReactContext_1 = require("./ReactContext");
const debug_1 = require("debug");
const typescript_1 = require("typescript");
const log = debug_1.debug("hardhat:plugin:react");
const TS_CONFIG = {
    target: ts_morph_1.ScriptTarget.ES2018,
    lib: ["dom", "dom.iterable", "esnext"],
    allowJs: true,
    skipLibCheck: true,
    esModuleInterop: true,
    allowSyntheticDefaultImports: true,
    strict: true,
    forceConsistentCasingInFileNames: true,
    module: ts_morph_1.ModuleKind.CommonJS,
    moduleResolution: ts_morph_1.ModuleResolutionKind.NodeJs,
    resolveJsonModule: true,
    isolatedModules: true,
    noEmit: true,
    jsx: typescript_1.JsxEmit.React,
};
const contractInterfaceName = (contract) => {
    return `Symfoni${contract.typechainInstanceName}`;
};
exports.contractInterfaceName = contractInterfaceName;
class TsMorphProject {
    constructor(args, hre) {
        this.hre = hre;
        this.args = args;
        this.HARDHAT_CONTEXT_FILE_NAME = "SymfoniContext.tsx";
        this.project = new ts_morph_1.Project({
            compilerOptions: TS_CONFIG,
        });
        this.ensure_hardhat_context_file();
    }
    async generate() {
        const hardhat_context_file = this.project.getSourceFile(this.HARDHAT_CONTEXT_FILE_NAME);
        if (!hardhat_context_file) {
            throw Error("After it assured hardhat context file in contruction, it could not resolve hardhat context file in generate.");
        }
        const contractContexts = await this.getContractContexts();
        const reactContext = new ReactContext_1.ReactContext(hardhat_context_file, this.args, this.hre, contractContexts);
        return reactContext.generate();
    }
    async save() {
        // if (true) {
        //   log("Verbode mode, get ready for Diagnostics");
        //   const sourceFile = this.project.getSourceFile(
        //     this.HARDHAT_CONTEXT_FILE_NAME
        //   );
        //   if (!sourceFile) throw Error("No Hardhat react context file");
        //   const emitOutput = sourceFile.getPreEmitDiagnostics();
        //   log(emitOutput);
        // }
        this.project.saveSync();
        return true;
    }
    async getContractContexts() {
        let currentNetwork = this.hre.network.name;
        // currentNetwork =
        //   currentNetwork === "hardhat" ? "localhost" : currentNetwork;
        log("Mapping deployments from " + currentNetwork + " to React context");
        const typechainFactoriesPath = path_1.default.resolve(this.hre.config.typechain.outDir, "factories");
        const relativeDeploymentsPath = path_1.default.relative(this.hre.config.paths.react, path_1.default.resolve(this.hre.config.paths.deployments, currentNetwork));
        const relativeTypechainsInstancePath = path_1.default.relative(this.hre.config.paths.react, this.hre.config.typechain.outDir);
        const relativeTypechainsFactoriesPath = path_1.default.relative(this.hre.config.paths.react, typechainFactoriesPath);
        const relativeArtifactsPath = path_1.default.relative(this.hre.config.paths.react, this.hre.config.paths.artifacts);
        let deploymentFiles = [];
        try {
            log("Checking deploymentfiles in " +
                path_1.default.resolve(this.hre.config.paths.deployments, currentNetwork));
            deploymentFiles = fs_extra_1.readdirSync(path_1.default.resolve(this.hre.config.paths.deployments, currentNetwork));
            log("deploymentFiles => ");
            log(deploymentFiles);
        }
        catch (error) {
            log("No deployment folder or files found.");
        }
        // TODO : Hardhat maybe rewrite later
        // const deploymentFiles = await this.hre.deployments.all();
        const artifactFiles = await this.hre.artifacts.getAllFullyQualifiedNames();
        log("artifactFiles => ");
        log(artifactFiles);
        const typechainInstanceFiles = fs_extra_1.readdirSync(this.hre.config.typechain.outDir);
        // TODO : Create PR to typechain for optional index file or implciit / explicit generation.
        fs_extra_1.removeSync(path_1.default.resolve(this.hre.config.typechain.outDir, "index.ts"));
        const typechainFactoriesFiles = fs_extra_1.readdirSync(typechainFactoriesPath);
        log("typechainInstanceFiles => ");
        log(typechainInstanceFiles);
        log("typechainFactoriesFiles => ");
        log(typechainFactoriesFiles);
        let contracts = [];
        await Promise.all([...artifactFiles].map(async (fileName) => {
            const artifactJson = await this.hre.artifacts.readArtifact(fileName);
            // Skip list
            if (this.hre.config.react.skip) {
                if (this.hre.config.react.skip.indexOf(artifactJson.contractName) !== -1) {
                    log("Skipping " + fileName + " because its in skip list.");
                    return;
                }
            }
            // Skip list
            if (this.hre.config.react.handle) {
                if (this.hre.config.react.handle.indexOf(artifactJson.contractName) ===
                    -1) {
                    log("Skipping " + fileName + " because its NOT in handle list.");
                    return;
                }
            }
            if (artifactJson.bytecode.length < 3) {
                // TODO handle interface contracts
                log("Skipping " + fileName + " because we think its a interface.");
                return;
            }
            const deploymentFile = deploymentFiles.find((deploymentFile) => {
                return (path_1.default.basename(deploymentFile, ".json") === artifactJson.contractName);
            });
            // TODO : Hardhat maybe rewrite later
            // const hasDeploymentFile = Object.prototype.hasOwnProperty.call(deploymentFiles, artifactName)
            // const deploymentFile = hasDeploymentFile ? deploymentFiles[artifactName] : undefined
            const typechainInstanceFile = typechainInstanceFiles.find((typechainFile) => {
                const hasInstanceFile = path_1.default.basename(typechainFile, ".d.ts") ===
                    artifactJson.contractName;
                return hasInstanceFile;
            });
            const typechainFactoryFile = typechainFactoriesFiles.find((typechainFile) => {
                const hasFactoryFile = path_1.default.basename(typechainFile, ".ts") ===
                    artifactJson.contractName + "__factory";
                return hasFactoryFile;
            });
            if (!typechainInstanceFile) {
                // if we dont a typechain file, we cant create anything. So lets just return
                log("No typechain instance for " + artifactJson.contractName);
                return;
            }
            if (!typechainFactoryFile) {
                // if we dont a typechain file, we cant create anything. So lets just return
                log("No typechain factory for " + artifactJson.contractName);
                return;
            }
            log("Creating context for " + artifactJson.contractName);
            contracts.push({
                name: artifactJson.contractName,
                typechainInstanceName: `${path_1.default.basename(typechainInstanceFile, ".d.ts")}`,
                typechainFactoryName: `${path_1.default.basename(typechainFactoryFile, ".ts")}`,
                deploymentFile: deploymentFile
                    ? `${relativeDeploymentsPath}/${deploymentFile}`
                    : undefined,
                artifactFile: `${relativeArtifactsPath}/${artifactJson.sourceName}`,
                typechainInstance: `${relativeTypechainsInstancePath}/${typechainInstanceFile}`,
                typechainFactory: `${relativeTypechainsFactoriesPath}/${typechainFactoryFile}`,
                instance: false,
            });
        }));
        // Filter out possible duplicates
        contracts = contracts.filter((contract, i, arr) => {
            const duplicate = arr.slice(0, i).findIndex((otherContract) => {
                return (contract.typechainInstance === otherContract.typechainInstance ||
                    contract.typechainFactory === otherContract.typechainFactory);
            }) !== -1;
            if (duplicate) {
                log(`Contract ${contract.name} is a duplicated. Removing the last instance of it from React context generation`);
            }
            return !duplicate;
        });
        let contractInstances = [];
        // Handle possible deployment instances
        deploymentFiles
            .filter((deploymentFile) => ![".chainId", "solcInputs"].includes(deploymentFile))
            .forEach((deploymentFile) => {
            const exist = contracts.find((contract) => {
                if (!contract.deploymentFile) {
                    return false;
                }
                return path_1.default.basename(contract.deploymentFile) === deploymentFile;
            });
            if (!exist) {
                log("Deployment " + deploymentFile + " had no contract.");
                // try to find the contract which has been used to instantiate the deploymentInstance
                const possibleContract = contracts.find((contract) => {
                    const deploymentFileNormalized = path_1.default
                        .basename(deploymentFile, ".json")
                        .toLowerCase();
                    const artifactFileNormalized = path_1.default
                        .basename(contract.artifactFile, ".sol")
                        .toLowerCase();
                    return deploymentFileNormalized.includes(artifactFileNormalized);
                });
                if (possibleContract) {
                    log("Found possible contract " +
                        possibleContract.name +
                        " for deploymentFile " +
                        deploymentFile);
                    contractInstances.push(Object.assign(Object.assign({}, possibleContract), { deploymentFile: `${relativeDeploymentsPath}/${deploymentFile}`, name: path_1.default.basename(deploymentFile, ".json"), instance: true }));
                }
            }
        });
        contracts = [...contractInstances, ...contracts];
        log(contracts.length + " contracts has been set for react context generation");
        log(contracts.map((c) => c.name).join(","));
        return contracts;
    }
    ensure_hardhat_context_file() {
        const exist = this.project
            .getSourceFiles()
            .find((file) => file.getBaseName() === this.HARDHAT_CONTEXT_FILE_NAME);
        if (!exist) {
            const newFile = this.project.createSourceFile(path_1.default.resolve(this.hre.config.paths.react, this.HARDHAT_CONTEXT_FILE_NAME), undefined, { overwrite: true });
        }
    }
}
exports.TsMorphProject = TsMorphProject;
//# sourceMappingURL=TsMorhProject.js.map