"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TASK_REACT_MAIN = exports.TASK_REACT = void 0;
const config_1 = require("hardhat/config");
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const TsMorhProject_1 = require("./TsMorhProject");
require("hardhat-deploy/dist/src/type-extensions");
require("hardhat-typechain/dist/src/type-extensions");
require("./type-extensions");
const debug_1 = require("debug");
exports.TASK_REACT = "react";
exports.TASK_REACT_MAIN = "react:main";
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const hardhat_deploy_1 = require("hardhat-deploy");
const log = debug_1.debug("hardhat:plugin:react");
config_1.extendConfig((config, userConfig) => {
    var _a, _b;
    // set default config
    if (!userConfig.react) {
        config.react = {
            providerPriority: ["web3modal", "hardhat"],
        };
    }
    else {
        // if (!userConfig.react.injectWallet) {
        //   config.react.injectWallet = false;
        // }
        if (!userConfig.react.providerPriority) {
            config.react.providerPriority = ["web3modal", "hardhat"];
        }
    }
    // Set react path
    const userReactPath = (_a = userConfig.paths) === null || _a === void 0 ? void 0 : _a.react;
    let newReactPath;
    if (userReactPath === undefined) {
        newReactPath = path_1.default.join(config.paths.root, "./frontend/src/hardhat");
    }
    else {
        if (path_1.default.isAbsolute(userReactPath)) {
            newReactPath = userReactPath;
        }
        else {
            newReactPath = path_1.default.normalize(path_1.default.join(config.paths.root, userReactPath));
        }
    }
    config.paths.react = newReactPath;
    // Set deployments path default
    const userDeploymentPath = (_b = userConfig.paths) === null || _b === void 0 ? void 0 : _b.deployments;
    if (userDeploymentPath === undefined) {
        const newDeploymentPath = path_1.default.join(config.paths.root, "./frontend/src/hardhat/deployments");
        config.paths.deployments = newDeploymentPath;
    }
    // Set some defaults for other plugins to get fast going.
    // deployer
    if (userConfig.namedAccounts == undefined) {
        config.namedAccounts = {
            deployer: {
                default: 0,
            },
        };
    }
    // typechain
    if (!userConfig.typechain) {
        // defaults
        config.typechain = {
            outDir: path_1.default.join(config.paths.root, "./frontend/src/hardhat/typechain"),
            target: "ethers-v5",
        };
    }
    else {
        const userTypechainOutdir = userConfig.typechain.outDir;
        let newTypechainPath;
        if (!userTypechainOutdir) {
            newTypechainPath = path_1.default.join(config.paths.root, "./frontend/src/hardhat/typechain");
        }
        else {
            if (path_1.default.isAbsolute(userTypechainOutdir)) {
                newTypechainPath = userTypechainOutdir;
            }
            else {
                newTypechainPath = path_1.default.normalize(path_1.default.join(config.paths.root, userTypechainOutdir));
            }
        }
        config.typechain.outDir = newTypechainPath;
        if (!userConfig.typechain.target) {
            config.typechain.target = "ethers-v5";
        }
    }
});
config_1.extendEnvironment((hre) => {
    // We add a field to the Hardhat Runtime Environment here.
    // We use lazyObject to avoid initializing things until they are actually
    // needed.
    // hre.example = lazyObject(() => new ExampleHardhatRuntimeEnvironmentField());
});
config_1.subtask(exports.TASK_REACT_MAIN, "Run React context component generation.").setAction(async (args, hre) => {
    await hre.run("typechain");
    log("Running Hardhat React");
    const context = new TsMorhProject_1.TsMorphProject(args, hre);
    log("START generate context");
    await context.generate();
    log("END generate context");
    log("START save context");
    await context.save();
    log("END save context");
    console.info(chalk_1.default.green("Successfully generated React context!"));
    return;
});
config_1.subtask(hardhat_deploy_1.TASK_DEPLOY_RUN_DEPLOY, "Generate react component after deploy").setAction(async (args, hre, runSuper) => {
    try {
        if (!runSuper.isDefined)
            throw Error("runSuper not defined for " + hardhat_deploy_1.TASK_DEPLOY_RUN_DEPLOY);
        await runSuper(Object.assign(Object.assign({}, args), { write: true }));
        await hre.run(exports.TASK_REACT_MAIN, args);
        return;
    }
    catch (e) {
        throw Error(e);
    }
});
config_1.subtask(task_names_1.TASK_NODE_SERVER_READY).setAction(async (args, hre, runSuper) => {
    if (!runSuper.isDefined)
        throw Error("runSuper not defined for " + task_names_1.TASK_NODE_SERVER_READY);
    await runSuper(args);
    console.log(chalk_1.default.blue(`Generating React context on change`));
});
config_1.task(exports.TASK_REACT, "Create React component")
    .addFlag("noReactOutput", "whether to save react context to disk") // TODO ADD more paramters (path, debug etc)
    .setAction(async (args, hre) => {
    await hre.run(exports.TASK_REACT_MAIN, args);
});
//# sourceMappingURL=index.js.map